<!DOCTYPE html>
<html>
<head>
    <title>Color Palette </title>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3-scale-radial.js"></script>
    <style>
        body {background: #000000;}

        .tooltip {
            position: absolute;
            pointer-events: none;
            background-color: #79797cb9;
            font-family: Arial;
            padding: 5px;
            font-size: 20px;
            color: #ffffff;
            text-anchor: end;
            border-radius: 6px;
        }

        #pallet-container {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			z-index: 1;
		}

        .selected {
            fill: yellow;
        }

    </style>
</head>
<body>

<div class="pallet-container">
    <input type="range" class="slider" id="slider1" min="0" max="255" value="0" step="1">
    <input type="range" class="slider" id="slider2" min="0" max="255" value="255" step="1">
    <div id="download-link-container"></div>
    <button id="downloadButton">Download Selected Colors</button>
    <div id="dataviz"></div>
</div>

</div>
<script>
    var width = screen.width
    var height = 1000

    var tooltip = d3.select("body").append("div")
        .style("opacity", 0)
        .attr("id", "tooltip")
        .attr("class", "tooltip")
        .attr('style', 'position: absolute; opacity: 0;');

    // append the svg object to the body of the page
    var svg = d3.select("#dataviz")
        .append("svg")
            .attr("width", width)
            .attr("height", height)

    let slider1 = d3.select("#slider1");
    let slider2 = d3.select("#slider2");

    /*function filterData(data,sliderValue) {
        let filteredData = data.colors.filter(d => d.cluster_size >= sliderValue);
        updateVisualization(filteredData,+d3.select("#slider1").property("value"),);
    }*/
    
    function filterData(data, minValue, maxValue) {
        let filteredData = data.colors.filter(d => d.cluster_size_rank >= minValue && d.cluster_size_rank <= maxValue);
        updateVisualization(filteredData, minValue);
    }

    function updateVisualization(filteredData, sliderValue) {
        svg.selectAll("*").remove();
        
        const pallete_output = {};
        d3.select("#downloadButton").on("click", function() {
            //button.on("click", () => {
            svg.selectAll("*").each(function() {
                if (d3.select(this).attr("clicks") % 2 !== 0){
                    pallete_output[d3.select(this).attr("id")] = {
                        "RGB":d3.select(this).attr("rgb"),
                        "Hue":d3.select(this).attr("hue"),
                        "Greyscale":d3.select(this).attr("gs"),
                        "Cluster Size":d3.select(this).attr("cluster_size"),
                        "Cluster Rank":d3.select(this).attr("cluster_rank"),
                        "Similar Pantone Color Name":d3.select(this).attr("pantone_name"),
                        "Similar Pantone Color Hex":d3.select(this).attr("pantone"),
                    }
                }
            });
            console.log(pallete_output);
            const jsonString = JSON.stringify(pallete_output, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'Selected_Colors.json';
            link.click();
            URL.revokeObjectURL(url);
        });

        var hues = [];
        var cluster_size = [];
        var cluster_size_ranks = [];
        filteredData.forEach(function(item) {
            hues.push(item.hue)
            cluster_size.push(item.cluster_size)
            cluster_size_ranks.push(item.cluster_size_rank)
        });
        var datalength = cluster_size_ranks.length;
        console.log(datalength);
        var min_hue = d3.min(hues);
        var max_hue = d3.max(hues);
        var min_cluster_size = d3.min(cluster_size);
        var max_cluster_size = d3.max(cluster_size);

        var min_cluster_rank = d3.min(cluster_size_ranks);
        var max_cluster_rank = d3.max(cluster_size_ranks);

        var xScale = d3.scaleLinear()
            .domain([0, 255])
            .range([200, width*.9]);

        var xScale_bars = d3.scaleLinear()
            .domain([min_cluster_size, max_cluster_size])
            .range([200, width*.5]);

        var yScale_bars = d3.scaleLinear()
            .domain([min_cluster_rank, max_cluster_rank])
            .range([height*.8, 100]);

        /*svg.append("text")
            .attr("x", 20) // Adjust x-coordinate for positioning
            .attr("y", 20) // Adjust y-coordinate for positioning
            .attr("text-anchor", "start")
            .style("fill", "white")
            .style("font-family", "Arial")
            .style("font-size", 25)
            .text("Palette dominance: " + sliderValue + "+% of palette");*/

        svg.selectAll("text")
            .data(filteredData)
            .enter()
            .append("text")
                .attr("x", function(d) { return xScale_bars(d.cluster_size + 3); })
                .attr("y", function(d) { return yScale_bars(d.cluster_size_rank - .3);})
                .attr("text-anchor", "start")
                .style("fill", "white")
                .style("font-family", "Arial")
                .style("font-size", (height/datalength)*.7)
                .text(d => `HEX: ${d.hex}, Pantone Name: ${d.pantone_name}`);

        var paths = svg.append("g")
            .selectAll("line")
            .data(filteredData)
            .enter()
            .append("line")
                .attr("clicks",0)
                .attr("rgb",function(d) { return d.rgb;})
                .attr("hue",function(d) { return d.hue;})
                .attr("gs",function(d) { return d.gs;})
                .attr("cluster_size",function(d) { return d.cluster_size;})
                .attr("cluster_rank",function(d) { return d.cluster_size_rank;})
                .attr("y1",  function(d) { return yScale_bars(d.cluster_size_rank);})
                .attr("y2",  function(d) { return yScale_bars(d.cluster_size_rank);})
                //.attr("x2", function(d) { return xScale_bars((d.cluster_size-min_cluster_size)/(max_cluster_size-min_cluster_size)); })
                .attr("x2", function(d) { return xScale_bars(d.cluster_size); })
                .attr("x1", 100)
                .attr("stroke", function(d) {return `rgb(${parseFloat(d.rgb[0])}, ${parseFloat(d.rgb[1])}, ${parseFloat(d.rgb[2])})`; })
                .style("stroke-width", (height/datalength)*.7)
                .style("stroke-opacity", 0.7)
                .attr("id",function(d) { return d.hex; })
                .attr("ref_category",function(d) { return d.ref_category; })
                .attr("ref_name",function(d) { return d.ref_name; })
                .attr("pantone_name",function(d) { return d.pantone_name; });

        paths.on("mouseover", function(d) {
            d3.select(this)
                .raise()
                .transition()
                .duration(200)
                .style("stroke-opacity", 1)
                .style("stroke-width", (height/datalength)*.85)
                tooltip
                    .style("left", (d3.select(this).attr("x1")) + "px")
                    .style("top", (d3.select(this).attr("y1")) + "px")
                    .style("width", function() {return (200) + "px"})
                    .style("stroke-opacity", 1)
                    .text(d3.select(this).attr("id")+": "+d3.select(this).attr("pantone_name")+": "+d3.select(this).attr("ref_name"));
        });

        paths.on("mouseout", function(d) {
            d3.select(this)
                .raise()
                .transition()
                .duration(200)
                .style("stroke-opacity", 0.7)
                .style("stroke-width", (height/datalength)*.7)
            tooltip
                .transition()
                .duration(200)
                .style('opacity', 0);
        });
        paths.on("click", function(d) {
            let clicks = parseFloat(d3.select(this).attr("clicks"));
            d3.select(this)
                .attr("clicks",clicks += 1);
            if (parseFloat(d3.select(this).attr("clicks")) % 2 !== 0){
                d3.select(this)
                    .style("stroke-opacity", 1)
                console.log(d3.select(this).attr("ref_name"))
            } else if (parseFloat(d3.select(this).attr("clicks")) % 2 === 0){
                d3.select(this)
                    .style("stroke-opacity", 0.7)
            };
        });
    };

    d3.json("../data/pallet.json", function(error, data) {
        if (error) {
            console.log("Error loading the JSON file:", error);
            return;
        }

        // Event listener for slider1
        slider1.on("input", function() {
            let minValue = +this.value; // Get the minimum slider value
            let maxValue = +slider2.property("value"); // Get the maximum slider value
            filterData(data, minValue, maxValue); // Call a function to filter data based on the slider values
        });

        // Event listener for slider2
        slider2.on("input", function() {
            let minValue = +slider1.property("value"); // Get the minimum slider value
            let maxValue = +this.value; // Get the maximum slider value
            filterData(data, minValue, maxValue); // Call a function to filter data based on the slider values
        });

        // Initial visualization update with default slider values
        let initialMinValue = +slider1.property("value");
        let initialMaxValue = +slider2.property("value");
        filterData(data, initialMinValue, initialMaxValue);
    });
</script>

</body>
</html>
